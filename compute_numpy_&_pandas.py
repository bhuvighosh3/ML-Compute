# -*- coding: utf-8 -*-
"""Compute numpy & pandas

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YJ-TP_SlhNr1SkXYuV1erRROZd8u-SEo

#### Import NumPy
"""

import numpy as np

"""#### Create an array of 10 zeros """

np.zeros(10)

"""#### Create an array of 10 ones"""

np.ones(10)

"""#### Create an array of 10 fives"""

np.full((10),5)

"""#### Create an array of the integers from 10 to 50 -!del!-"""

np.arange(10,51,1)

#np.linspace(10,51,50)

"""#### Create an array of all the even integers from 10 to 50  -!del!-"""

np.arange(10,51,2)

"""#### Create a 3x3 matrix with values ranging from 0 to 8"""



"""#### Create a 3x3 identity matrix"""

np.eye(3)

"""#### Use NumPy to generate a random number between 0 and 1  -!del!-"""

np.random.uniform(0,1,size=(1,1))

np.random.rand()

'''
np.random.randint(1,100,size=(5,5))
'''

"""#### Use NumPy to generate an array of 25 random numbers sampled from a standard normal distribution"""

np.random.normal(size=(1,25))



"""#### Create the following matrix: -!del!-"""

np.arange(0,1,0.01)

"""#### Create an array of 20 linearly spaced points between 0 and 1: """

np.linspace(0,1,20)

"""## Numpy Indexing and Selection

Now you will be given a few matrices, and be asked to replicate the resulting matrix outputs:
"""

mat = np.arange(1,26).reshape(5,5)
mat

# WRITE CODE HERE THAT REPRODUCES THE OUTPUT OF THE CELL BELOW
# BE CAREFUL NOT TO RUN THE CELL BELOW, OTHERWISE YOU WON'T
# BE ABLE TO SEE THE OUTPUT ANY MORE
np.array([12,13,14,15,16,18,19,20,22,23,24,25]).reshape(3,4)



# WRITE CODE HERE THAT REPRODUCES THE OUTPUT OF THE CELL BELOW
# BE CAREFUL NOT TO RUN THE CELL BELOW, OTHERWISE YOU WON'T
# BE ABLE TO SEE THE OUTPUT ANY MORE
np.array([20],ndmin=0)



# WRITE CODE HERE THAT REPRODUCES THE OUTPUT OF THE CELL BELOW
# BE CAREFUL NOT TO RUN THE CELL BELOW, OTHERWISE YOU WON'T
# BE ABLE TO SEE THE OUTPUT ANY MORE

np.array([2,7,12]).reshape(3,1)

# WRITE CODE HERE THAT REPRODUCES THE OUTPUT OF THE CELL BELOW
# BE CAREFUL NOT TO RUN THE CELL BELOW, OTHERWISE YOU WON'T
# BE ABLE TO SEE THE OUTPUT ANY MORE
np.array([21,22,23,24,25])



# WRITE CODE HERE THAT REPRODUCES THE OUTPUT OF THE CELL BELOW
# BE CAREFUL NOT TO RUN THE CELL BELOW, OTHERWISE YOU WON'T
# BE ABLE TO SEE THE OUTPUT ANY MORE
np.arange(16,26).reshape(2,5)



"""### Now do the following

#### Get the sum of all the values in mat
"""

x=np.array([55,60,65,70,75])
np.sum(x)

"""#### Get the standard deviation of the values in mat"""

x=np.array([55,60,65,70,75])
np.std(x)

"""#### Get the sum of all the columns in mat"""

x=np.array([55,60,65,70,75])
np.sum(x,axis=0)



"""#### Multiply two matrices using NumPy.

A = [[1, 2], [2, 3]]

B = [[4, 5], [6, 7]]

So, A.B = [[1*4 + 2*6, 2*4 + 3*6], [1*5 + 2*7, 2*5 + 3*7]

The computed answer will be: [[16, 26], [19, 31]]

"""

x=np.array([[1,2],[2,3]])
y=np.array([[4,5],[6,7]])
np.dot(x,y)

"""####Replace NaN values with average of that column

Initial array :  

[[ 1.3  2.5  3.6  nan]
 [ 2.6  3.3  nan  5.5]
 [ 2.1  3.2  5.4  6.5]]

"""

'''
x=np.array([[1.3,2.5,3.6,np.nan],[2.6,3.3,np.nan,5.5],[2.1,3.2,5.4,6.5]])
l=x.mean(axis=1).tolist()
print(l)
for i in x:
  for j in i:
    if j==np.nan:
      j=l[i]
print(x)
'''

# Initialising numpy array
ini_array = np.array([[1.3, 2.5, 3.6, np.nan], 
                      [2.6, 3.3, np.nan, 5.5],
                      [2.1, 3.2, 5.4, 6.5]])
  
# printing initial array
print ("initial array", ini_array)
  
# column mean
col_mean = np.nanmean(ini_array, axis =0)
  
# printing column mean
print ("columns mean",list(col_mean))
  
# find indices where nan value is present
inds = np.where(np.isnan(ini_array))

# replace inds with avg of column
ini_array[inds] = np.take(col_mean, inds[1])
  
# printing final array
print ("final array", ini_array)

'''
Searching
x=np.array([1,3,4])
if 7 in x:
  print("Element is found")
else:
  print("Nothing is found")
'''

"""# You're done!"""

import pandas as pd
df = pd.read_csv("/content/data (1).csv")

"""#Pandas

##### First 5 rows:
"""

df.head()

"""##### Last 5 rows:"""

df.tail()

df.info()

"""#####Inference: There are 16 columns in the DataFrame. We can also observe that there are 2017 data points.There are no Null values.Datatypes of all the columns are mentioned in the data frame."""

#df.sort_values('danceability')[['song_title', 'artist']].head(10)

#df.sort_values('duration_ms',ascending=False)[['song_title', 'artist', 'duration_ms']].head(10)

#df_filt = df[df['duration_ms'] < 400000]

'''
df2= df_filt.sort_values('energy',ascending=False)[['song_title', 'energy']].head(10)
print(df2)
'''

"""Q)Find songs with value for energy column greater than 0.4 and display values for song_title column."""

newdf=df[df['energy']>0.4]
newdf[['song_title']]

"""Q)For songs with duration duration_ms value less than 300000 ms (300 s), find Top 10 “fastest” songs( songs with highest values for tempo column ) and display values for song_title, artistcolumns."""

newdf=df[df['duration_ms']<300000]
newdf.sort_values('tempo',ascending=False)[['song_title','artist']].head(10)

"""####ascending=False is used for arranging the dataframe in a descending order according to the tempo & head() gives the top 10 entries.

#####Q) Find songs with value for artist column = Drake and value for energy column greater than 0.5 and display values for song_title & artist column.
"""

newdf=df[df['energy']>0.5][['song_title','artist']]

newdf[newdf['artist']=='Drake'][['song_title','artist']]

"""#####Q)Create a dataframe of the songs that rank among top 10 for the instrumentalness metric. This dataframe should only contain the instrumentalness, song title and artist columns.

"""

df.sort_values('instrumentalness',ascending=False)[['instrumentalness','artist','song_title']].head(10)

"""####ascending=False is used for arranging the dataframe in a descending order according to instrunmentalness.

#####Q)Create a dataframe of the average tempo for each of the top 10 most occurring artists.
"""

x=df['artist'].value_counts(dropna=False)
pd.DataFrame(x).sort_values('artist',ascending=False).head(10)

"""df['artist'].value_counts(dropna=False) gives the count of each artist.
dropna=False is used as it also counts the missing values if present in a dataset.
"""

df.groupby('artist').count().sort_values('artist',ascending=False).head(10)['tempo']